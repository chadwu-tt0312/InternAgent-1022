# 協助理解產生的結果
_Exported on 2025/10/31 at 16:43:57 [GMT+8] from Cursor (2.0.43)_

---

**User**

 產生的結果 @20251031_144833_internagent.log (511-513)  看不懂。請協助理解 @ideas.json 和 @AutoSeg_ideas_session_1761893314.pdf 

---

**Cursor**


檢視這兩個檔案的內容與生成流程，協助理解。


檢視可視化函數的實作，以便理解 PDF 的內容：


以下是這兩個文件的說明：

## 文件說明

### 1. `ideas.json` — 生成的3個研究方法

這是系統使用 MAS（Multi-Agent System）為 AutoSeg（語義分割）任務生成的3個方法，內容如下：

#### 方法1: **SNN-DAA+**
- 脈衝神經網絡 + 自適應注意力機制的語義分割
- 核心：無參數注意力模組，降低記憶體使用並提升特徵表示
- 架構：Encoder → PFAA（注意力）→ Decoder

#### 方法2: **CAAM-Enhanced SegDepth**
- 多任務框架：同時做語義分割與深度估計
- 核心：上下文感知注意力模組（CAAM），整合邊界感知特徵
- 架構：共享編碼器 → CAAM → 兩個解碼器（分割/深度）

#### 方法3: **cGAN-DeepLabV3+ with Enhanced Attention**
- 條件生成對抗網絡 + DeepLabV3+ + 多尺度注意力
- 核心：結合 cGAN 與 DeepLabV3+，增強邊界準確度
- 架構：cGAN Generator → DeepLabV3+ → 多尺度注意力 → 最終分割圖

每個方法包含：
- 系統架構描述
- 數學公式與符號定義
- 演算法流程（含偽代碼）
- 複雜度分析
- 實作可行性說明
- 創新性陳述

### 2. `AutoSeg_ideas_session_1761893314.pdf` — 可視化文件

這是使用 `visualize_hypotheses()` 函數生成的 PDF，包含：
- 想法的演進關係圖（父子關係）
- 每個想法的評分資訊
- 相關文獻證據
- 方法詳細描述的可視化呈現

## 生成流程（根據日誌）

```
1. 啟動想法生成（MAS系統）
   ↓
2. 多個 Agent 協作產生想法
   ↓
3. 評分與篩選出 Top 3 想法
   ↓
4. 生成 ideas.json（結構化方法描述）
   ↓
5. 生成 PDF 可視化（想法關係圖）
```

## 文件用途

- `ideas.json`：結構化的方法描述，可用於：
  - 程式實作
  - 論文撰寫
  - 實驗配置
- `PDF 文件`：快速了解想法間的演進關係與評分

需要我進一步解釋某個特定方法的技術細節嗎？

```plaintext
1. 啟動想法生成（MAS系統）
   ↓
2. 多個 Agent 協作產生想法
   ↓
3. 評分與篩選出 Top 3 想法
   ↓
4. 生成 ideas.json（結構化方法描述）
   ↓
5. 生成 PDF 可視化（想法關係圖）
```

---

**User**

1. 生成的 PDF 中 "方法詳細描述的可視化呈現" 沒有完整的訊息，是否產生的 PDF 格式有問題?

2.  "相關文獻證據" 的 title 訊息也不完整

要如何修改?

---

**Cursor**


檢視 PDF 生成程式碼，找出並修正文字截斷問題：


檢視實際的 JSON 結構，確認資料格式：


檢查實際的 trajectory JSON 文件以確認結構：


檢視實際的 trajectory JSON 文件結構：


修正兩個問題：
1. 方法描述：目前僅顯示 `idea['text']`，需顯示完整的 `refined_method_details`。
2. 文獻標題：標題被截斷，需允許完整顯示與換行。


修改 `vis.py`，完整顯示方法描述並允許文獻標題完整顯示與換行：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Significantly increase the height ratio for the top section and add more space between sections
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 2.5, 1.5],  # Increased middle section for idea content
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Base height + title + content lines + scores + padding
                total_height = 3 + text_height + (2 if scores else 1)
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Truncate long titles more aggressively
            truncated_title = evidence['title']
            if len(truncated_title) > 55:  # Further reduced character limit
                truncated_title = truncated_title[:52] + '...'
            
            # Create row data
            row = [
                str(i+1),  # Reference number
                truncated_title,
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Create the table with custom column widths - more compact
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.03, 0.65, 0.17, 0.05, 0.1]  # Adjusted widths
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability - more compact
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Smaller font for better fit
            table.scale(1, 1.1)  # More compact rows
            
            # Set cell heights and adjust text properties to prevent overlap
            for (i, j), cell in table.get_celld().items():
                cell.set_height(0.04)  # More compact
                
                # Make title column text smaller and ensure wrapping
                if j == 1:  # Title column
                    cell.get_text().set_fontsize(6)  # Even smaller for titles
                    cell.get_text().set_wrap(True)
                    cell.get_text().set_va('center')
                
                # Make idea IDs smaller too
                if j == 2:  # Idea column
                    cell.get_text().set_fontsize(6)
                    cell.get_text().set_wrap(True)
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Significantly increase the height ratio for the top section and add more space between sections
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 2.5, 1.5],  # Increased middle section for idea content
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Base height + title + content lines + scores + padding
                total_height = 3 + text_height + (2 if scores else 1)
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Create the table with custom column widths - more compact
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.03, 0.65, 0.17, 0.05, 0.1]  # Adjusted widths
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability - more compact
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Smaller font for better fit
            table.scale(1, 1.1)  # More compact rows
            
            # Set cell heights and adjust text properties to prevent overlap
            for (i, j), cell in table.get_celld().items():
                cell.set_height(0.04)  # More compact
                
                # Make title column text smaller and ensure wrapping
                if j == 1:  # Title column
                    cell.get_text().set_fontsize(6)  # Even smaller for titles
                    cell.get_text().set_wrap(True)
                    cell.get_text().set_va('center')
                
                # Make idea IDs smaller too
                if j == 2:  # Idea column
                    cell.get_text().set_fontsize(6)
                    cell.get_text().set_wrap(True)
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Significantly increase the height ratio for the top section and add more space between sections
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 2.5, 1.5],  # Increased middle section for idea content
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Base height + title + content lines + scores + padding
                total_height = 3 + text_height + (2 if scores else 1)
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            table.scale(1, 1.3)  # Increased row height to accommodate wrapped text
            
            # Set cell heights and adjust text properties to prevent overlap
            for (i, j), cell in table.get_celld().items():
                # Increase cell height for title column to allow wrapping
                if j == 1:  # Title column
                    cell.set_height(0.08)  # Doubled height for title column
                    cell.get_text().set_fontsize(7)  # Increased from 6 to 7
                    cell.get_text().set_wrap(True)  # Enable text wrapping
                    cell.get_text().set_va('top')  # Align to top for multi-line text
                    # Calculate line breaks for long titles
                    title_text = table_data[i-1][j] if i > 0 else ''
                    if len(title_text) > 60:
                        # Break into multiple lines (approximately 60 chars per line)
                        wrapped_lines = textwrap.wrap(title_text, width=60)
                        cell.get_text().set_text('\n'.join(wrapped_lines))
                elif j == 2:  # Idea column
                    cell.set_height(0.04)
                    cell.get_text().set_fontsize(6)
                    cell.get_text().set_wrap(True)
                else:
                    cell.set_height(0.04)  # Standard height for other columns
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

調整中間區域高度，以容納更長的方法描述：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Base height + title + content lines + scores + padding
                total_height = 3 + text_height + (2 if scores else 1)
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            table.scale(1, 1.3)  # Increased row height to accommodate wrapped text
            
            # Set cell heights and adjust text properties to prevent overlap
            for (i, j), cell in table.get_celld().items():
                # Increase cell height for title column to allow wrapping
                if j == 1:  # Title column
                    cell.set_height(0.08)  # Doubled height for title column
                    cell.get_text().set_fontsize(7)  # Increased from 6 to 7
                    cell.get_text().set_wrap(True)  # Enable text wrapping
                    cell.get_text().set_va('top')  # Align to top for multi-line text
                    # Calculate line breaks for long titles
                    title_text = table_data[i-1][j] if i > 0 else ''
                    if len(title_text) > 60:
                        # Break into multiple lines (approximately 60 chars per line)
                        wrapped_lines = textwrap.wrap(title_text, width=60)
                        cell.get_text().set_text('\n'.join(wrapped_lines))
                elif j == 2:  # Idea column
                    cell.set_height(0.04)
                    cell.get_text().set_fontsize(6)
                    cell.get_text().set_wrap(True)
                else:
                    cell.set_height(0.04)  # Standard height for other columns
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea with refined_method_details
                is_current = node in top_ideas
                method_extra_height = 0
                if is_current:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            table.scale(1, 1.3)  # Increased row height to accommodate wrapped text
            
            # Set cell heights and adjust text properties to prevent overlap
            for (i, j), cell in table.get_celld().items():
                # Increase cell height for title column to allow wrapping
                if j == 1:  # Title column
                    cell.set_height(0.08)  # Doubled height for title column
                    cell.get_text().set_fontsize(7)  # Increased from 6 to 7
                    cell.get_text().set_wrap(True)  # Enable text wrapping
                    cell.get_text().set_va('top')  # Align to top for multi-line text
                    # Calculate line breaks for long titles
                    title_text = table_data[i-1][j] if i > 0 else ''
                    if len(title_text) > 60:
                        # Break into multiple lines (approximately 60 chars per line)
                        wrapped_lines = textwrap.wrap(title_text, width=60)
                        cell.get_text().set_text('\n'.join(wrapped_lines))
                elif j == 2:  # Idea column
                    cell.set_height(0.04)
                    cell.get_text().set_fontsize(6)
                    cell.get_text().set_wrap(True)
                else:
                    cell.set_height(0.04)  # Standard height for other columns
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

修正判斷邏輯：僅在當前 idea 頁面顯示完整方法描述。


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            table.scale(1, 1.3)  # Increased row height to accommodate wrapped text
            
            # Set cell heights and adjust text properties to prevent overlap
            for (i, j), cell in table.get_celld().items():
                # Increase cell height for title column to allow wrapping
                if j == 1:  # Title column
                    cell.set_height(0.08)  # Doubled height for title column
                    cell.get_text().set_fontsize(7)  # Increased from 6 to 7
                    cell.get_text().set_wrap(True)  # Enable text wrapping
                    cell.get_text().set_va('top')  # Align to top for multi-line text
                    # Calculate line breaks for long titles
                    title_text = table_data[i-1][j] if i > 0 else ''
                    if len(title_text) > 60:
                        # Break into multiple lines (approximately 60 chars per line)
                        wrapped_lines = textwrap.wrap(title_text, width=60)
                        cell.get_text().set_text('\n'.join(wrapped_lines))
                elif j == 2:  # Idea column
                    cell.set_height(0.04)
                    cell.get_text().set_fontsize(6)
                    cell.get_text().set_wrap(True)
                else:
                    cell.set_height(0.04)  # Standard height for other columns
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

修正標題換行邏輯：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            table.scale(1, 1.3)  # Increased row height to accommodate wrapped text
            
            # Set cell heights and adjust text properties to prevent overlap
            for (i, j), cell in table.get_celld().items():
                # Increase cell height for title column to allow wrapping
                if j == 1:  # Title column
                    # Calculate appropriate height based on title length
                    if i > 0:  # Data rows (skip header)
                        title_text = table_data[i-1][j] if i-1 < len(table_data) else ''
                        # Estimate number of lines needed (approximately 60 chars per line)
                        estimated_lines = max(1, (len(title_text) + 55) // 60)
                        cell.set_height(0.04 * estimated_lines)  # Dynamic height based on content
                        
                        # Pre-wrap long titles for better display
                        if len(title_text) > 60:
                            wrapped_lines = textwrap.wrap(title_text, width=60)
                            cell.get_text().set_text('\n'.join(wrapped_lines))
                        else:
                            cell.get_text().set_text(title_text)
                    else:
                        # Header row
                        cell.set_height(0.06)
                    
                    cell.get_text().set_fontsize(7)  # Increased from 6 to 7
                    cell.get_text().set_wrap(True)  # Enable text wrapping
                    cell.get_text().set_va('top')  # Align to top for multi-line text
                elif j == 2:  # Idea column
                    cell.set_height(0.04)
                    cell.get_text().set_fontsize(6)
                    cell.get_text().set_wrap(True)
                else:
                    cell.set_height(0.04)  # Standard height for other columns
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查修改後的代碼是否有錯誤：


已修復兩個問題，摘要如下：

## 修改摘要

### 1. **方法詳細描述顯示**

**問題**：PDF 只顯示簡短的 `idea['text']`，沒有顯示完整的 `refined_method_details`。

**解決方案**：
- 檢查是否存在 `refined_method_details`
- 若有，顯示：
  - 方法名稱 (`name`)
  - 方法標題 (`title`)
  - 方法描述 (`description`) — 顯示前 5 行
  - 系統架構概述 (`System Architecture.Overview`) — 顯示前 3 行
- 增加中間區塊高度比例：從 `2.5` 調整為 `3.5`
- 動態計算額外高度以容納方法詳情

### 2. **文獻標題完整顯示**

**問題**：標題被截斷到 55 個字元（`truncated_title[:52] + '...'`）。

**解決方案**：
- 移除標題截斷，顯示完整標題
- 增加標題欄位寬度：從 `0.65` 調整為 `0.70`
- 啟用自動換行：長標題自動換行（約 60 字元/行）
- 動態調整儲存格高度：根據標題長度調整
- 提高字體大小：從 `6` 調整為 `7`
- 增加表格行高：`scale(1, 1.3)` 以容納多行文字

## 主要修改位置

1. **第 284-317 行**：加入方法詳細描述的顯示邏輯
2. **第 382-397 行**：移除標題截斷，使用完整標題
3. **第 401-465 行**：優化表格格式，支援多行標題顯示

## 測試建議

重新生成 PDF 以驗證效果：

```bash
# 如果有的話，可以重新運行視覺化
python -c "from internagent.vis import visualize_hypotheses; visualize_hypotheses('results/AutoSeg/traj_session_1761893314.json', 'results/AutoSeg/AutoSeg_ideas_session_1761893314_updated.pdf')"
```

PDF 應可完整顯示：
- 方法的詳細描述（名稱、標題、描述、架構）
- 完整的文獻標題（自動換行）

如需進一步調整（例如顯示更多方法細節或調整換行寬度），告訴我。

```shellscript
# 如果有的話，可以重新運行視覺化
python -c "from internagent.vis import visualize_hypotheses; visualize_hypotheses('results/AutoSeg/traj_session_1761893314.json', 'results/AutoSeg/AutoSeg_ideas_session_1761893314_updated.pdf')"
```

---

**User**

"文獻標題" 格式看起來不整齊

---

**Cursor**


標題換行導致行高不一致，其他欄位內容無法對齊。統一所有行的行高，讓表格更整齊：


統一表格行高，讓所有行高度一致：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Base height per line, with extra padding
            uniform_row_height = 0.04 * max_lines_per_title + 0.01  # Add small padding
            uniform_row_height = max(uniform_row_height, 0.06)  # Minimum height
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.06)
                    cell.get_text().set_fontsize(8)
                    cell.get_text().set_weight('bold')
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查是否有遺漏的部分：


已修復表格格式，主要變更如下：

## 修改內容

### 問題
- 標題換行導致不同行的標題行數不同
- 其他欄位（Idea、Year、Relevance）高度不一致
- 內容垂直置中，造成對齊混亂

### 解決方案

1. 預處理標題
   - 預先換行所有標題
   - 計算所有標題中的最大行數

2. 統一列高
   - 根據最大行數計算統一的列高
   - 所有行的所有列使用相同高度（基於最長標題所需行數）

3. 統一對齊
   - 所有欄位內容對齊到頂部（`va='top'`）
   - 水平對齊為左對齊（`ha='left'`）

4. 標題格式
   - 長標題自動換行（每行約 60 字元）
   - 預先處理後再放入表格，確保格式一致

## 效果

- 所有行的標題欄位高度一致
- Idea、Year、Relevance 欄位內容水平對齊
- 表格外觀更整齊

重新生成 PDF 時，表格應呈現一致的高度與對齊。

---

**User**

表格侵占到 "Evidence Used by This Idea and Its Ancestors" 的空間，表格欄位高度可以縮小

---

**Cursor**


修正兩個問題：
1. 表格標題被覆蓋：增加標題與表格的間距
2. 表格欄位過高：縮小行高


修正表格標題覆蓋並縮小欄位高度：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Reduced base height per line for more compact table
            uniform_row_height = 0.025 * max_lines_per_title + 0.005  # Reduced padding
            uniform_row_height = max(uniform_row_height, 0.04)  # Reduced minimum height
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.06)
                    cell.get_text().set_fontsize(8)
                    cell.get_text().set_weight('bold')
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Reduced base height per line for more compact table
            uniform_row_height = 0.025 * max_lines_per_title + 0.005  # Reduced padding
            uniform_row_height = max(uniform_row_height, 0.04)  # Reduced minimum height
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=10)
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Reduced base height per line for more compact table
            uniform_row_height = 0.025 * max_lines_per_title + 0.005  # Reduced padding
            uniform_row_height = max(uniform_row_height, 0.04)  # Reduced minimum height
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Reduced base height per line for more compact table
            uniform_row_height = 0.025 * max_lines_per_title + 0.005  # Reduced padding
            uniform_row_height = max(uniform_row_height, 0.04)  # Reduced minimum height
            
            # Create the table with custom column widths - increased title width
            # Position table lower to avoid title overlap
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                bbox=[0, 0, 1, 0.85],  # Position table lower: [x0, y0, width, height], y0=0 means bottom
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查修改是否有問題，必要時調整表格定位：


調整表格定位方式，移除可能導致問題的 bbox 參數：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Reduced base height per line for more compact table
            uniform_row_height = 0.025 * max_lines_per_title + 0.005  # Reduced padding
            uniform_row_height = max(uniform_row_height, 0.04)  # Reduced minimum height
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

已修正表格標題覆蓋與欄位高度的問題。修改如下：

## 修改內容

### 1. 縮小表格欄位高度

**行高計算：**
- 從 `0.04 * max_lines_per_title + 0.01` 改為 `0.025 * max_lines_per_title + 0.005`（約減少 37.5%）
- 最小行高從 `0.06` 改為 `0.04`（約減少 33%）

**表頭高度：**
- 從 `0.06` 改為 `0.045`（約減少 25%）
- 表頭字體從 `8` 改為 `7`

### 2. 防止標題覆蓋

**標題間距：**
- 將 `pad=10` 改為 `pad=25`，增加標題與表格之間的空間

## 效果

- 表格更緊湊：行高縮小約 33–37%
- 標題不再被覆蓋：增加上方間距
- 保持可讀性：字體大小適中

重新生成 PDF 時，表格應更緊湊，且標題不會被表格內容覆蓋。

---

**User**

表格文字位置偏下，導致多行時，內容跨越格線

---

**Cursor**


檢查並修正垂直對齊，避免多行文字跨越格線：


為表格儲存格加入內部邊距（padding），確保文字不貼近格線：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Reduced base height per line for more compact table
            uniform_row_height = 0.025 * max_lines_per_title + 0.005  # Reduced padding
            uniform_row_height = max(uniform_row_height, 0.04)  # Reduced minimum height
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.set_pad(0.02)  # Add padding to header cells
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    # Add padding to all data cells to prevent text from touching grid lines
                    # Top and bottom padding to ensure text doesn't cross grid lines
                    cell.set_pad(0.015)  # Set padding (will be applied to all sides)
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                        # Extra bottom padding for multi-line titles to prevent crossing grid lines
                        cell.PAD = 0.015  # Ensure consistent padding
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                        cell.PAD = 0.015
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
                        cell.PAD = 0.015
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

調整行高計算，為多行文字預留更多底部空間，避免貼近格線：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Reduced base height per line for more compact table, but with extra bottom padding
            # Add extra space at bottom to prevent text from crossing grid lines
            uniform_row_height = 0.025 * max_lines_per_title + 0.01  # Add extra padding at bottom
            uniform_row_height = max(uniform_row_height, 0.045)  # Increased minimum to allow for padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.set_pad(0.02)  # Add padding to header cells
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    # Add padding to all data cells to prevent text from touching grid lines
                    # Top and bottom padding to ensure text doesn't cross grid lines
                    cell.set_pad(0.015)  # Set padding (will be applied to all sides)
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                        # Extra bottom padding for multi-line titles to prevent crossing grid lines
                        cell.PAD = 0.015  # Ensure consistent padding
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                        cell.PAD = 0.015
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
                        cell.PAD = 0.015
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Reduced base height per line for more compact table, but with extra bottom padding
            # Add extra space at bottom to prevent text from crossing grid lines
            uniform_row_height = 0.025 * max_lines_per_title + 0.01  # Add extra padding at bottom
            uniform_row_height = max(uniform_row_height, 0.045)  # Increased minimum to allow for padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.set_pad(0.02)  # Add padding to header cells
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    # Set padding for all cells to prevent text from touching grid lines
                    cell.set_pad(0.01)  # Internal padding for text positioning
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查是否有其他需要調整的地方，確保文字正確對齊：


已修正文字位置偏下並跨越格線的問題。修改如下：

## 修改內容

### 1. **增加行高計算中的底部空間**
- 從 `0.005` 增加到 `0.01`，為多行文字預留更多底部空間
- 最小行高從 `0.04` 增加到 `0.045`，確保有足夠空間容納 padding

### 2. **為所有儲存格添加內部邊距（Padding）**
- 表頭儲存格：`cell.set_pad(0.02)`
- 數據儲存格：`cell.set_pad(0.01)`
- 這會在所有方向上（上、下、左、右）添加內邊距，防止文字貼近格線

### 3. **確保文字頂部對齊**
- 所有欄位文字皆設定為 `va='top'`（垂直對齊到頂部）
- 配合 padding，文字與格線之間會有適當間距

## 效果預期

- 文字不再跨越格線：padding 確保文字與底部格線保持距離
- 多行標題正確顯示：頂部對齊，底部有足夠空間
- 表格更整齊：統一的行高與對齊方式

重新生成 PDF 後，表格文字應不再跨越格線，並與格線保持適當距離。

---

**User**

@zsh (999-1009) 

---

**Cursor**


修正錯誤：matplotlib 的 `Cell` 物件沒有 `set_pad` 方法。移除 `set_pad`，改用調整行高與文字位置來提供間距：


移除錯誤的 `set_pad` 調用，改用增加行高來提供間距：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.set_pad(0.02)  # Add padding to header cells
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    # Set padding for all cells to prevent text from touching grid lines
                    cell.set_pad(0.01)  # Internal padding for text positioning
                    
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top to match other columns
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            
            # Set uniform cell heights for all cells in each row
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - use uniform height for all columns
                    # Set same height for all columns in the same row
                    cell.set_height(uniform_row_height)
                    
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

驗證修改是否正確：


已修正錯誤。變更如下：

## 修正內容

### 1. **移除錯誤的方法調用**
- 移除 `cell.set_pad()`（matplotlib 的 Cell 物件沒有此方法）

### 2. **通過增加行高提供底部空間**
- 每行高度：從 `0.025` 增加到 `0.028`
- 底部額外空間：從 `0.01` 增加到 `0.012`
- 最小行高：從 `0.045` 增加到 `0.048`

### 3. **確保文字頂部對齊**
- 所有數據行的文字使用 `va='top'`（垂直對齊到頂部）
- 文字從儲存格頂部開始，底部有餘裕，避免跨越格線

## 解決方案原理

由於 matplotlib 表格 Cell 物件不支援直接設置 padding，改為：
1. 增加行高，為多行文字提供更多底部空間
2. 使用頂部對齊（`va='top'`），文字從頂部開始，底部自然留空
3. 統一行高，確保對齊一致

請再次執行命令測試：

```bash
python3 -c "from internagent.vis import visualize_hypotheses; visualize_hypotheses('results/AutoSeg/traj_session_1761893314.json', 'results/AutoSeg/AutoSeg_ideas_session_1761893314_updated4.pdf')"
```

這應可解決錯誤，並避免文字跨越格線。

```shellscript
python3 -c "from internagent.vis import visualize_hypotheses; visualize_hypotheses('results/AutoSeg/traj_session_1761893314.json', 'results/AutoSeg/AutoSeg_ideas_session_1761893314_updated4.pdf')"
```

---

**User**

1. 表格欄位高度不一樣
2. 表格"又"侵占到 "Evidence Used by This Idea and Its Ancestors" 的空間

---

**Cursor**


檢查並修正這兩個問題：


檢查 GridSpec 設置，確保表格有足夠空間：


修正兩個問題：確保行高統一，並增加標題與表格的間距。


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells
                    # Force same height for all columns in the same row
                    cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set)
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Data rows only
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=25)  # Increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.0],  # Further increased middle section for method details
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.2)  # Increased vertical space
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells
                    # Force same height for all columns in the same row
                    cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set)
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Data rows only
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=35)  # Further increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.2],  # Increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.25)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                if len(title_text) > 60:
                    wrapped_lines = textwrap.wrap(title_text, width=60)
                    wrapped_titles.append('\n'.join(wrapped_lines))
                    max_lines_per_title = max(max_lines_per_title, len(wrapped_lines))
                else:
                    wrapped_titles.append(title_text)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells
                    # Force same height for all columns in the same row
                    cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set)
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Data rows only
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=35)  # Further increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

驗證修改並確保高度設置正確：


已修正兩個問題，變更如下：

## 修正內容

### 1. **統一表格欄位高度**

**問題**：行高不一致，因為某些儲存格可能沒有正確應用統一高度。

**解決方案**：
- 分兩步處理：先統一設置所有儲存格高度，再設置文字屬性
- 確保所有數據行的所有欄位都使用相同的 `uniform_row_height`
- 添加註釋，避免使用 `table.scale()`（會覆蓋高度設置）
- 在所有數據行儲存格上明確調用 `cell.set_height(uniform_row_height)`

### 2. **防止表格侵占標題空間**

**問題**：即使 `pad=25`，表格仍過於接近標題。

**解決方案**：
- 增加標題間距：從 `pad=25` 增加到 `pad=35`
- 調整 GridSpec 高度比例：底部區域從 `2.0` 增加到 `2.2`
- 增加區域間距：`hspace` 從 `0.2` 增加到 `0.25`

## 關鍵改進

**分離高度設置與文字設置**：
```python
# 第一步：統一設置所有儲存格高度
for (i, j), cell in table.get_celld().items():
    if i > 0:
        cell.set_height(uniform_row_height)

# 第二步：設置文字屬性（高度已統一）
for (i, j), cell in table.get_celld().items():
    if i > 0:
        # 設置文字對齊、字體等
```

這樣可以確保：
- 所有行的所有欄位高度完全一致
- 標題與表格之間有足夠的間距
- 多行標題不會跨越格線

請重新生成 PDF 測試，應該會看到：
1. 所有表格行的高度完全一致
2. 標題與表格之間有充足的間距

```python
# 第一步：統一設置所有儲存格高度
for (i, j), cell in table.get_celld().items():
    if i > 0:
        cell.set_height(uniform_row_height)

# 第二步：設置文字屬性（高度已統一）
for (i, j), cell in table.get_celld().items():
    if i > 0:
        # 設置文字對齊、字體等
```

---

**User**

@AutoSeg_ideas_session_1761893314.pdf 
修改過，但問題依然存在
1. 表格欄位高度不一樣
2. 表格"又"侵占到 "Evidence Used by This Idea and Its Ancestors" 的空間

---

**Cursor**


檢查並修正這兩個問題，重點在確保所有行高度一致，並增加標題與表格的間距：


檢查換行計算邏輯，並修正表格定位問題：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.2],  # Increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.25)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells
                    # Force same height for all columns in the same row
                    cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set)
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Data rows only
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=35)  # Further increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.2],  # Increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.25)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            # Position table lower to avoid title overlap
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                bbox=[0, 0, 1, 0.80],  # Position table lower: y0=0 (bottom), height=0.80
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells
                    # Force same height for all columns in the same row
                    cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set)
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Data rows only
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=35)  # Further increased pad to prevent overlap
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.2],  # Increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.25)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            # Position table lower to avoid title overlap
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                bbox=[0, 0, 1, 0.80],  # Position table lower: y0=0 (bottom), height=0.80
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            for (i, j), cell in table.get_celld().items():
                if i == 0:  # Header row
                    cell.set_height(0.045)  # Reduced header height
                    cell.get_text().set_fontsize(7)  # Slightly smaller font
                    cell.get_text().set_weight('bold')
                    cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells
                    # Force same height for all columns in the same row
                    cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set)
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Data rows only
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.2],  # Increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.25)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            # Position table lower to avoid title overlap
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                bbox=[0, 0, 1, 0.80],  # Position table lower: y0=0 (bottom), height=0.80
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set)
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Data rows only
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.2],  # Increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.25)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            # Position table lower to avoid title overlap
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                bbox=[0, 0, 1, 0.80],  # Position table lower: y0=0 (bottom), height=0.80
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

調整 GridSpec，增加底部區域空間，並確保標題與表格有足夠間距：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            # Position table lower to avoid title overlap
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                bbox=[0, 0, 1, 0.80],  # Position table lower: y0=0 (bottom), height=0.80
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

移除可能造成問題的 bbox 設置，改用更穩定的方法：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length (with some padding)
            node_font_size = font_size  # Use the provided font size
            char_width = node_font_size * 0.6  # Approximate width per character
            text_width = len(node) * char_width
            rect_width = max(text_width + 30, 130)  # Add padding with minimum width
            rect_height = 35  # Fixed height
            
            # Create rectangle with rounded corners
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.3",
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text
            ax1.text(x, y, node, ha='center', va='center', fontsize=node_font_size, 
                    fontweight='bold', color='black')
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

已修正兩個問題，修改如下：

## 主要修正

### 1. **統一表格欄位高度**

**問題根源**：未正確計算所有標題的最大行數，且高度設置方式不可靠。

**解決方案**：
- 改進行數計算：處理已包含換行的標題，正確計算總行數
  ```python
  # 正確處理已有換行的標題
  existing_lines = title_text.count('\n') + 1
  # 分別處理每個部分並正確計數
  ```
- 強制統一高度：使用明確的索引遍歷所有儲存格
  ```python
  for i in range(len(table_data) + 1):  # 明確遍歷所有行
      for j in range(5):  # 明確遍歷所有列
          cell = table[(i, j)]  # 直接索引，不依賴迭代順序
          cell.set_height(uniform_row_height)  # 強制設置
  ```
- 確保所有數據行的所有欄位都使用相同的 `uniform_row_height`

### 2. **防止表格侵占標題空間**

**解決方案**：
- 增加標題間距：`pad=45`（從 35 增加）
- 設置標題位置：`y=1.0`（定位在子圖頂部）
- 增加底部區域空間：
  - `height_ratios`：底部區域從 `2.2` 增加到 `2.5`
  - `hspace`：區域間距從 `0.25` 增加到 `0.3`

## 關鍵改進

**使用明確索引而非迭代器**：
- 之前：`for (i, j), cell in table.get_celld().items()`（可能順序不確定）
- 現在：`for i in range(...): for j in range(5): cell = table[(i, j)]`（明確且可預測）

**正確計算最大行數**：
- 處理已包含 `\n` 的標題
- 分別處理每個部分並正確計數總行數

請重新生成 PDF 測試，應可看到：
1. ✅ 所有表格行的所有欄位高度完全一致
2. ✅ 標題與表格之間有充足的間距

如果問題仍存在，請告訴我，我會進一步調整。

```python
  # 正確處理已有換行的標題
  existing_lines = title_text.count('\n') + 1
  # 分別處理每個部分並正確計數

```

```python
  for i in range(len(table_data) + 1):  # 明確遍歷所有行
      for j in range(5):  # 明確遍歷所有列
          cell = table[(i, j)]  # 直接索引，不依賴迭代順序
          cell.set_height(uniform_row_height)  # 強制設置

```

---

**User**

修正重疊的文字與表格

---

**Cursor**


檢查並修正文字與表格重疊問題：


檢查並修正節點矩形寬度計算，確保長 ID 不會溢出：


修正節點矩形寬度計算與文字溢出問題：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length with better estimation
            # For monospace fonts, use more accurate calculation
            node_font_size = font_size  # Use the provided font size
            
            # More accurate width calculation considering font metrics
            # Average character width for bold font is approximately 0.55-0.6 * font_size
            char_width = node_font_size * 0.65  # Slightly larger for better fit
            text_width = len(node) * char_width
            
            # Add generous padding to prevent text overlap with rectangle edges
            # Padding should be at least 40 pixels on each side (80 total) for long IDs
            padding = max(80, len(node) * 2)  # Dynamic padding based on text length
            rect_width = max(text_width + padding, 150)  # Increased minimum width
            
            # Increase height slightly to accommodate text better
            rect_height = 40  # Increased from 35
            
            # Create rectangle with rounded corners and more padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.5",  # Increased padding
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text with clipping to prevent overflow
            # Use text wrapping for very long IDs if needed
            display_text = node
            if len(node) > 50:  # For very long IDs, truncate with ellipsis
                display_text = node[:47] + "..."
            
            ax1.text(x, y, display_text, ha='center', va='center', 
                    fontsize=node_font_size, 
                    fontweight='bold', color='black',
                    clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            x_min, x_max = min(x_values) - 150, max(x_values) + 150
            y_min, y_max = min(y_values) - 80, max(y_values) + 80
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width based on ID length with better estimation
            # For monospace fonts, use more accurate calculation
            node_font_size = font_size  # Use the provided font size
            
            # More accurate width calculation considering font metrics
            # Average character width for bold font is approximately 0.55-0.6 * font_size
            char_width = node_font_size * 0.65  # Slightly larger for better fit
            text_width = len(node) * char_width
            
            # Add generous padding to prevent text overlap with rectangle edges
            # Padding should be at least 40 pixels on each side (80 total) for long IDs
            padding = max(80, len(node) * 2)  # Dynamic padding based on text length
            rect_width = max(text_width + padding, 150)  # Increased minimum width
            
            # Increase height slightly to accommodate text better
            rect_height = 40  # Increased from 35
            
            # Create rectangle with rounded corners and more padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=0.5",  # Increased padding
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8)
            ax1.add_patch(rect)
            
            # Add node ID text with clipping to prevent overflow
            # Use text wrapping for very long IDs if needed
            display_text = node
            if len(node) > 50:  # For very long IDs, truncate with ellipsis
                display_text = node[:47] + "..."
            
            ax1.text(x, y, display_text, ha='center', va='center', 
                    fontsize=node_font_size, 
                    fontweight='bold', color='black',
                    clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Need larger padding to accommodate wider rectangles for long IDs
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes
            max_rect_width = 0
            for node in subgraph.nodes():
                node_font_size = font_size
                char_width = node_font_size * 0.65
                text_width = len(node) * char_width
                padding = max(80, len(node) * 2)
                rect_width = max(text_width + padding, 150)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add padding based on maximum rectangle width
            x_padding = max(200, max_rect_width / 2 + 50)  # Ensure enough space for widest node
            y_padding = 100  # Increased vertical padding
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查並確認表格與標題的間距是否足夠：


已修正文字與表格的重疊問題。修改如下：

## 修正內容

### 1. **節點矩形寬度計算優化**

**問題**：長 ID（如 `idea_1761893314_0005379_0_0000_000000_2`）會導致文字與矩形邊界重疊或溢出。

**解決方案**：
- 改進字元寬度計算：從 `0.6 * font_size` 調整為 `0.65 * font_size`
- 動態 padding：根據文字長度計算，至少 80 像素
  ```python
  padding = max(80, len(node) * 2)  # 動態 padding
  ```
- 增加矩形高度：從 `35` 調整為 `40`
- 增加矩形內部邊距：`boxstyle` 的 `pad` 從 `0.3` 調整為 `0.5`
- 超長 ID 處理：超過 50 字元時截斷並加上 "..."
- 啟用文字裁剪：`clip_on=True` 防止溢出

### 2. **座標軸邊界調整**

**問題**：節點可能超出繪圖區域。

**解決方案**：
- 計算所有節點的最大矩形寬度
- 根據最大寬度動態設置 x 軸 padding
- 增加 y 軸 padding 到 100 像素

### 3. **表格與標題間距**

先前已修正：
- 標題 `pad=45`
- 底部區域高度增加到 `2.5`
- 區域間距 `hspace=0.3`

## 效果

- ✅ 長 ID 完全包含在矩形內，不溢出
- ✅ 文字與矩形邊界有足夠間距
- ✅ 節點不會超出繪圖區域
- ✅ 表格與標題間距足夠，不會重疊

重新生成 PDF 後，應可看到：
1. 所有節點 ID 完整顯示在矩形內
2. 文字與矩形邊界有適當間距
3. 表格與標題之間有足夠空間

若仍有重疊，請告知，我會進一步調整。

```python
  padding = max(80, len(node) * 2)  # 動態 padding
```

---

**User**

修改過，但問題依然存在
修正重疊的文字與表格

---

**Cursor**


檢查當前實作，採用更徹底的解決方案：


改用更準確的方法測量文字寬度，並確保矩形足夠寬：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        # First, create temporary text objects to measure actual text width
        temp_texts = {}
        node_font_size = font_size
        
        for node in subgraph.nodes():
            # Create temporary text object to measure actual width
            temp_text = ax1.text(0, 0, node, fontsize=node_font_size, 
                               fontweight='bold', transform=ax1.transData)
            # Get the bounding box to measure actual text width
            temp_text.set_visible(False)  # Hide temporary text
            bbox = temp_text.get_window_extent(renderer=fig.canvas.get_renderer())
            text_width_pixels = bbox.width
            temp_texts[node] = (text_width_pixels, temp_text)
        
        # Now draw rectangles and texts with accurate measurements
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Use measured text width instead of estimation
            text_width_pixels, temp_text = temp_texts[node]
            
            # Convert pixels to data coordinates for accurate sizing
            # Get transform to convert from display to data coordinates
            inv_trans = ax1.transData.inverted()
            # Convert pixel width to data coordinates
            # Approximate: 1 pixel ≈ (x_range / figure_width_in_pixels)
            x_range = ax1.get_xlim()[1] - ax1.get_xlim()[0] if ax1.get_xlim()[0] != ax1.get_xlim()[1] else 1
            fig_width_pixels = fig.get_figwidth() * fig.dpi
            pixels_to_data = x_range / fig_width_pixels
            text_width_data = text_width_pixels * pixels_to_data
            
            # Remove temporary text
            temp_text.remove()
            
            # Add VERY generous padding to prevent any overlap
            # Use 25% of text width as padding on each side (50% total)
            padding_data = max(text_width_data * 0.5, 100 * pixels_to_data)  # At least 100 pixels
            rect_width = text_width_data + padding_data
            
            # Set minimum width based on font size and ensure enough space
            min_width = node_font_size * 8 * pixels_to_data  # Minimum 8 characters width
            rect_width = max(rect_width, min_width)
            
            # Increase height to accommodate text better
            rect_height = 45  # Further increased from 40
            
            # Create rectangle with rounded corners and more padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.0",  # Even more padding
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Slightly thicker border for visibility
            ax1.add_patch(rect)
            
            # Add node ID text - no truncation needed with proper sizing
            text_obj = ax1.text(x, y, node, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True,  # Enable clipping as safety
                               bbox=dict(boxstyle='round,pad=0', facecolor='none', edgecolor='none'))  # Invisible bbox for spacing
            
            # Ensure text stays within rectangle bounds
            text_obj.set_clip_path(rect)
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Need larger padding to accommodate wider rectangles for long IDs
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes
            max_rect_width = 0
            for node in subgraph.nodes():
                node_font_size = font_size
                char_width = node_font_size * 0.65
                text_width = len(node) * char_width
                padding = max(80, len(node) * 2)
                rect_width = max(text_width + padding, 150)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add padding based on maximum rectangle width
            x_padding = max(200, max_rect_width / 2 + 50)  # Ensure enough space for widest node
            y_padding = 100  # Increased vertical padding
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

改用更簡單且可靠的方法：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        node_font_size = font_size
        
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width with very generous padding for long IDs
            # Use a more conservative estimation that accounts for variable character widths
            # Underestimate font size multiplier to be safe
            char_width_factor = 0.7  # Slightly larger for safety margin
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding: at least 60% of text width as padding
            # For very long IDs, use even more padding
            if len(node) > 40:
                padding_factor = 0.8  # 80% padding for very long IDs
            elif len(node) > 30:
                padding_factor = 0.7  # 70% padding for long IDs
            else:
                padding_factor = 0.6  # 60% padding for normal IDs
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            
            # Ensure minimum width for readability
            min_width = node_font_size * 10  # Minimum 10 character widths
            rect_width = max(rect_width, min_width)
            
            # Increase height significantly to accommodate text better
            rect_height = 50  # Increased to 50
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text with clip path to ensure it stays within bounds
            text_obj = ax1.text(x, y, node, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping
            
            # Set clip path to rectangle to ensure text never exceeds bounds
            text_obj.set_clip_path(rect.get_path(), transform=rect.get_transform())
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Need larger padding to accommodate wider rectangles for long IDs
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes
            max_rect_width = 0
            for node in subgraph.nodes():
                node_font_size = font_size
                char_width = node_font_size * 0.65
                text_width = len(node) * char_width
                padding = max(80, len(node) * 2)
                rect_width = max(text_width + padding, 150)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add padding based on maximum rectangle width
            x_padding = max(200, max_rect_width / 2 + 50)  # Ensure enough space for widest node
            y_padding = 100  # Increased vertical padding
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查並修正 clip_path 的使用方式：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        node_font_size = font_size
        
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width with very generous padding for long IDs
            # Use a more conservative estimation that accounts for variable character widths
            # Underestimate font size multiplier to be safe
            char_width_factor = 0.7  # Slightly larger for safety margin
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding: at least 60% of text width as padding
            # For very long IDs, use even more padding
            if len(node) > 40:
                padding_factor = 0.8  # 80% padding for very long IDs
            elif len(node) > 30:
                padding_factor = 0.7  # 70% padding for long IDs
            else:
                padding_factor = 0.6  # 60% padding for normal IDs
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            
            # Ensure minimum width for readability
            min_width = node_font_size * 10  # Minimum 10 character widths
            rect_width = max(rect_width, min_width)
            
            # Increase height significantly to accommodate text better
            rect_height = 50  # Increased to 50
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Need larger padding to accommodate wider rectangles for long IDs
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes
            max_rect_width = 0
            for node in subgraph.nodes():
                node_font_size = font_size
                char_width = node_font_size * 0.65
                text_width = len(node) * char_width
                padding = max(80, len(node) * 2)
                rect_width = max(text_width + padding, 150)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add padding based on maximum rectangle width
            x_padding = max(200, max_rect_width / 2 + 50)  # Ensure enough space for widest node
            y_padding = 100  # Increased vertical padding
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

更新座標軸邊界計算，使其與新的矩形寬度計算一致：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with more compact spacing
        try:
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', args='-Grankdir=TB -Gnodesep=0.3 -Granksep=0.4')
        except ImportError:
            # Fallback if graphviz is not available
            pos = nx.spring_layout(subgraph)
            print("Warning: Graphviz not available. Using spring layout instead.")
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        node_font_size = font_size
        
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width with very generous padding for long IDs
            # Use a more conservative estimation that accounts for variable character widths
            # Underestimate font size multiplier to be safe
            char_width_factor = 0.7  # Slightly larger for safety margin
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding: at least 60% of text width as padding
            # For very long IDs, use even more padding
            if len(node) > 40:
                padding_factor = 0.8  # 80% padding for very long IDs
            elif len(node) > 30:
                padding_factor = 0.7  # 70% padding for long IDs
            else:
                padding_factor = 0.6  # 60% padding for normal IDs
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            
            # Ensure minimum width for readability
            min_width = node_font_size * 10  # Minimum 10 character widths
            rect_width = max(rect_width, min_width)
            
            # Increase height significantly to accommodate text better
            rect_height = 50  # Increased to 50
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Need larger padding to accommodate wider rectangles for long IDs
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes using new formula
            max_rect_width = 0
            node_font_size = font_size
            for node in subgraph.nodes():
                char_width_factor = 0.7
                base_width = len(node) * node_font_size * char_width_factor
                
                # Use same padding logic as in rectangle creation
                if len(node) > 40:
                    padding_factor = 0.8
                elif len(node) > 30:
                    padding_factor = 0.7
                else:
                    padding_factor = 0.6
                
                padding = base_width * padding_factor
                rect_width = base_width + padding
                min_width = node_font_size * 10
                rect_width = max(rect_width, min_width)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add very generous padding based on maximum rectangle width
            # Use at least 60% of max width as padding on each side
            x_padding = max(300, max_rect_width * 0.6)  # Very generous horizontal padding
            y_padding = 120  # Increased vertical padding for taller rectangles
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查表格部分，確保沒有重疊：


已實作更徹底的解決方案。修改摘要如下：

## 修正內容

### 1. **節點矩形寬度計算**

**新的計算方式**：
- 基礎寬度：`len(node) * font_size * 0.7`
- 動態 padding（根據 ID 長度）：
  - ID > 40 字元：80% padding
  - ID > 30 字元：70% padding
  - 一般：60% padding
- 最小寬度：`font_size * 10`（約 10 個字元寬度）
- 矩形高度：增加到 `50`
- 內部邊距：`pad=1.5`

### 2. **長 ID 文字換行**

**超長 ID 處理**：
- 超過 45 字元時自動換行
- 優先在底線（`_`）處分割
- 換行後文字仍在矩形內

### 3. **座標軸邊界**

**增加邊距**：
- X 軸 padding：至少 300，或最大矩形寬度的 60%
- Y 軸 padding：增加到 120
- 確保所有節點（含長矩形）完整可見

### 4. **表格重疊問題**

先前已修正：
- 標題 `pad=45`，`y=1.0`
- 底部區域高度 `2.5`
- 區域間距 `hspace=0.3`
- 統一的行高設置

## 改進重點

1. 更寬鬆的 padding：根據 ID 長度動態調整（60%-80%）
2. 文字換行：超長 ID 自動換行顯示
3. 更大的矩形：高度增加到 50，內部邊距 1.5
4. 更寬的邊界：座標軸 padding 增加

請重新生成 PDF 測試，應可看到：
- ✅ 所有節點 ID 完整顯示，無文字溢出
- ✅ 文字與矩形邊界有充足間距
- ✅ 超長 ID 自動換行
- ✅ 表格與標題間距足夠

若問題仍存在，請提供具體細節以便進一步調整。

---

**User**

修改過二次，但問題依然存在

修正重疊的文字與表格

---

**Cursor**


檢查節點重疊的原因，著重查看節點定位與間距：


修正節點重疊問題：調整布局參數並檢查重疊：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with MORE spacing to prevent overlap
        try:
            # Increase nodesep and ranksep significantly to prevent node overlap
            # nodesep: minimum space between nodes in the same rank
            # ranksep: minimum space between ranks
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', 
                                              args='-Grankdir=TB -Gnodesep=2.0 -Granksep=1.5 -Gmargin=0.5')
        except (ImportError, Exception) as e:
            # Fallback if graphviz is not available or fails
            # Use spring layout with increased iterations and k parameter for better spacing
            print(f"Warning: Graphviz not available or failed ({e}). Using spring layout with increased spacing.")
            # Increase k (optimal distance between nodes) based on number of nodes and their width
            # Estimate average node width
            avg_node_width = sum(len(node) * font_size * 0.7 for node in subgraph.nodes()) / max(len(subgraph.nodes()), 1)
            k_value = max(avg_node_width * 1.5, 5.0)  # At least 5.0
            pos = nx.spring_layout(subgraph, k=k_value, iterations=200, seed=42)
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        node_font_size = font_size
        
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Get color based on level
            node_color = node_color_map[node]
            
            # Calculate rectangle width with very generous padding for long IDs
            # Use a more conservative estimation that accounts for variable character widths
            # Underestimate font size multiplier to be safe
            char_width_factor = 0.7  # Slightly larger for safety margin
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding: at least 60% of text width as padding
            # For very long IDs, use even more padding
            if len(node) > 40:
                padding_factor = 0.8  # 80% padding for very long IDs
            elif len(node) > 30:
                padding_factor = 0.7  # 70% padding for long IDs
            else:
                padding_factor = 0.6  # 60% padding for normal IDs
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            
            # Ensure minimum width for readability
            min_width = node_font_size * 10  # Minimum 10 character widths
            rect_width = max(rect_width, min_width)
            
            # Increase height significantly to accommodate text better
            rect_height = 50  # Increased to 50
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Need larger padding to accommodate wider rectangles for long IDs
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes using new formula
            max_rect_width = 0
            node_font_size = font_size
            for node in subgraph.nodes():
                char_width_factor = 0.7
                base_width = len(node) * node_font_size * char_width_factor
                
                # Use same padding logic as in rectangle creation
                if len(node) > 40:
                    padding_factor = 0.8
                elif len(node) > 30:
                    padding_factor = 0.7
                else:
                    padding_factor = 0.6
                
                padding = base_width * padding_factor
                rect_width = base_width + padding
                min_width = node_font_size * 10
                rect_width = max(rect_width, min_width)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add very generous padding based on maximum rectangle width
            # Use at least 60% of max width as padding on each side
            x_padding = max(300, max_rect_width * 0.6)  # Very generous horizontal padding
            y_padding = 120  # Increased vertical padding for taller rectangles
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

添加重疊檢測與自動調整機制：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with MORE spacing to prevent overlap
        try:
            # Increase nodesep and ranksep significantly to prevent node overlap
            # nodesep: minimum space between nodes in the same rank
            # ranksep: minimum space between ranks
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', 
                                              args='-Grankdir=TB -Gnodesep=2.0 -Granksep=1.5 -Gmargin=0.5')
        except (ImportError, Exception) as e:
            # Fallback if graphviz is not available or fails
            # Use spring layout with increased iterations and k parameter for better spacing
            print(f"Warning: Graphviz not available or failed ({e}). Using spring layout with increased spacing.")
            # Increase k (optimal distance between nodes) based on number of nodes and their width
            # Estimate average node width
            avg_node_width = sum(len(node) * font_size * 0.7 for node in subgraph.nodes()) / max(len(subgraph.nodes()), 1)
            k_value = max(avg_node_width * 1.5, 5.0)  # At least 5.0
            pos = nx.spring_layout(subgraph, k=k_value, iterations=200, seed=42)
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        node_font_size = font_size
        
        # First pass: Calculate all rectangle dimensions and store node info
        node_rects = {}
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Calculate rectangle dimensions
            char_width_factor = 0.7
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding
            if len(node) > 40:
                padding_factor = 0.8
            elif len(node) > 30:
                padding_factor = 0.7
            else:
                padding_factor = 0.6
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            min_width = node_font_size * 10
            rect_width = max(rect_width, min_width)
            rect_height = 50
            
            node_rects[node] = {
                'x': x, 'y': y,
                'width': rect_width, 'height': rect_height,
                'color': node_color_map[node]
            }
        
        # Second pass: Adjust positions to prevent overlap
        # Check for overlaps and adjust positions
        nodes_list = list(subgraph.nodes())
        adjusted_pos = {node: (node_rects[node]['x'], node_rects[node]['y']) for node in nodes_list}
        
        # Simple overlap resolution: if rectangles overlap, increase separation
        max_iterations = 10
        for iteration in range(max_iterations):
            overlaps_found = False
            for i, node1 in enumerate(nodes_list):
                x1, y1 = adjusted_pos[node1]
                w1, h1 = node_rects[node1]['width'], node_rects[node1]['height']
                
                for node2 in nodes_list[i+1:]:
                    x2, y2 = adjusted_pos[node2]
                    w2, h2 = node_rects[node2]['width'], node_rects[node2]['height']
                    
                    # Check if rectangles overlap
                    # Overlap if: |x1-x2| < (w1+w2)/2 AND |y1-y2| < (h1+h2)/2
                    x_overlap = abs(x1 - x2) < (w1 + w2) / 2
                    y_overlap = abs(y1 - y2) < (h1 + h2) / 2
                    
                    if x_overlap and y_overlap:
                        overlaps_found = True
                        # Separate nodes: move them apart
                        sep_x = (w1 + w2) / 2 + 20  # Minimum 20 units separation
                        sep_y = (h1 + h2) / 2 + 20
                        
                        if x1 < x2:
                            adjusted_pos[node1] = (x1 - sep_x/4, y1)
                            adjusted_pos[node2] = (x2 + sep_x/4, y2)
                        else:
                            adjusted_pos[node1] = (x1 + sep_x/4, y1)
                            adjusted_pos[node2] = (x2 - sep_x/4, y2)
                        
                        if y1 < y2:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 - sep_y/4)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 + sep_y/4)
                        else:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 + sep_y/4)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 - sep_y/4)
            
            if not overlaps_found:
                break
        
        # Third pass: Draw rectangles and texts with adjusted positions
        for node in subgraph.nodes():
            x, y = adjusted_pos[node]
            rect_info = node_rects[node]
            node_color = rect_info['color']
            rect_width = rect_info['width']
            rect_height = rect_info['height']
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Need larger padding to accommodate wider rectangles for long IDs
        x_values = [pos[node][0] for node in subgraph.nodes()]
        y_values = [pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes using new formula
            max_rect_width = 0
            node_font_size = font_size
            for node in subgraph.nodes():
                char_width_factor = 0.7
                base_width = len(node) * node_font_size * char_width_factor
                
                # Use same padding logic as in rectangle creation
                if len(node) > 40:
                    padding_factor = 0.8
                elif len(node) > 30:
                    padding_factor = 0.7
                else:
                    padding_factor = 0.6
                
                padding = base_width * padding_factor
                rect_width = base_width + padding
                min_width = node_font_size * 10
                rect_width = max(rect_width, min_width)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add very generous padding based on maximum rectangle width
            # Use at least 60% of max width as padding on each side
            x_padding = max(300, max_rect_width * 0.6)  # Very generous horizontal padding
            y_padding = 120  # Increased vertical padding for taller rectangles
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with MORE spacing to prevent overlap
        try:
            # Increase nodesep and ranksep significantly to prevent node overlap
            # nodesep: minimum space between nodes in the same rank
            # ranksep: minimum space between ranks
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', 
                                              args='-Grankdir=TB -Gnodesep=2.0 -Granksep=1.5 -Gmargin=0.5')
        except (ImportError, Exception) as e:
            # Fallback if graphviz is not available or fails
            # Use spring layout with increased iterations and k parameter for better spacing
            print(f"Warning: Graphviz not available or failed ({e}). Using spring layout with increased spacing.")
            # Increase k (optimal distance between nodes) based on number of nodes and their width
            # Estimate average node width
            avg_node_width = sum(len(node) * font_size * 0.7 for node in subgraph.nodes()) / max(len(subgraph.nodes()), 1)
            k_value = max(avg_node_width * 1.5, 5.0)  # At least 5.0
            pos = nx.spring_layout(subgraph, k=k_value, iterations=200, seed=42)
    
        # Draw edges
        nx.draw_networkx_edges(subgraph, pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        node_font_size = font_size
        
        # First pass: Calculate all rectangle dimensions and store node info
        node_rects = {}
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Calculate rectangle dimensions
            char_width_factor = 0.7
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding
            if len(node) > 40:
                padding_factor = 0.8
            elif len(node) > 30:
                padding_factor = 0.7
            else:
                padding_factor = 0.6
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            min_width = node_font_size * 10
            rect_width = max(rect_width, min_width)
            rect_height = 50
            
            node_rects[node] = {
                'x': x, 'y': y,
                'width': rect_width, 'height': rect_height,
                'color': node_color_map[node]
            }
        
        # Second pass: Adjust positions to prevent overlap
        # Check for overlaps and adjust positions
        nodes_list = list(subgraph.nodes())
        adjusted_pos = {node: (node_rects[node]['x'], node_rects[node]['y']) for node in nodes_list}
        
        # Simple overlap resolution: if rectangles overlap, increase separation
        max_iterations = 10
        for iteration in range(max_iterations):
            overlaps_found = False
            for i, node1 in enumerate(nodes_list):
                x1, y1 = adjusted_pos[node1]
                w1, h1 = node_rects[node1]['width'], node_rects[node1]['height']
                
                for node2 in nodes_list[i+1:]:
                    x2, y2 = adjusted_pos[node2]
                    w2, h2 = node_rects[node2]['width'], node_rects[node2]['height']
                    
                    # Check if rectangles overlap
                    # Overlap if: |x1-x2| < (w1+w2)/2 AND |y1-y2| < (h1+h2)/2
                    x_overlap = abs(x1 - x2) < (w1 + w2) / 2
                    y_overlap = abs(y1 - y2) < (h1 + h2) / 2
                    
                    if x_overlap and y_overlap:
                        overlaps_found = True
                        # Separate nodes: move them apart
                        sep_x = (w1 + w2) / 2 + 20  # Minimum 20 units separation
                        sep_y = (h1 + h2) / 2 + 20
                        
                        if x1 < x2:
                            adjusted_pos[node1] = (x1 - sep_x/4, y1)
                            adjusted_pos[node2] = (x2 + sep_x/4, y2)
                        else:
                            adjusted_pos[node1] = (x1 + sep_x/4, y1)
                            adjusted_pos[node2] = (x2 - sep_x/4, y2)
                        
                        if y1 < y2:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 - sep_y/4)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 + sep_y/4)
                        else:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 + sep_y/4)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 - sep_y/4)
            
            if not overlaps_found:
                break
        
        # Third pass: Draw rectangles and texts with adjusted positions
        for node in subgraph.nodes():
            x, y = adjusted_pos[node]
            rect_info = node_rects[node]
            node_color = rect_info['color']
            rect_width = rect_info['width']
            rect_height = rect_info['height']
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Use adjusted positions for calculating limits
        x_values = [adjusted_pos[node][0] for node in subgraph.nodes()]
        y_values = [adjusted_pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes using new formula
            max_rect_width = 0
            node_font_size = font_size
            for node in subgraph.nodes():
                char_width_factor = 0.7
                base_width = len(node) * node_font_size * char_width_factor
                
                # Use same padding logic as in rectangle creation
                if len(node) > 40:
                    padding_factor = 0.8
                elif len(node) > 30:
                    padding_factor = 0.7
                else:
                    padding_factor = 0.6
                
                padding = base_width * padding_factor
                rect_width = base_width + padding
                min_width = node_font_size * 10
                rect_width = max(rect_width, min_width)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add very generous padding based on maximum rectangle width
            # Use at least 60% of max width as padding on each side
            x_padding = max(300, max_rect_width * 0.6)  # Very generous horizontal padding
            y_padding = 120  # Increased vertical padding for taller rectangles
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

更新邊的繪製，使用調整後的位置：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with MORE spacing to prevent overlap
        try:
            # Increase nodesep and ranksep significantly to prevent node overlap
            # nodesep: minimum space between nodes in the same rank
            # ranksep: minimum space between ranks
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', 
                                              args='-Grankdir=TB -Gnodesep=2.0 -Granksep=1.5 -Gmargin=0.5')
        except (ImportError, Exception) as e:
            # Fallback if graphviz is not available or fails
            # Use spring layout with increased iterations and k parameter for better spacing
            print(f"Warning: Graphviz not available or failed ({e}). Using spring layout with increased spacing.")
            # Increase k (optimal distance between nodes) based on number of nodes and their width
            # Estimate average node width
            avg_node_width = sum(len(node) * font_size * 0.7 for node in subgraph.nodes()) / max(len(subgraph.nodes()), 1)
            k_value = max(avg_node_width * 1.5, 5.0)  # At least 5.0
            pos = nx.spring_layout(subgraph, k=k_value, iterations=200, seed=42)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        # (Edges will be drawn after position adjustment to prevent misalignment)
        node_font_size = font_size
        
        # First pass: Calculate all rectangle dimensions and store node info
        node_rects = {}
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Calculate rectangle dimensions
            char_width_factor = 0.7
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding
            if len(node) > 40:
                padding_factor = 0.8
            elif len(node) > 30:
                padding_factor = 0.7
            else:
                padding_factor = 0.6
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            min_width = node_font_size * 10
            rect_width = max(rect_width, min_width)
            rect_height = 50
            
            node_rects[node] = {
                'x': x, 'y': y,
                'width': rect_width, 'height': rect_height,
                'color': node_color_map[node]
            }
        
        # Second pass: Adjust positions to prevent overlap
        # Check for overlaps and adjust positions
        nodes_list = list(subgraph.nodes())
        adjusted_pos = {node: (node_rects[node]['x'], node_rects[node]['y']) for node in nodes_list}
        
        # Simple overlap resolution: if rectangles overlap, increase separation
        max_iterations = 10
        for iteration in range(max_iterations):
            overlaps_found = False
            for i, node1 in enumerate(nodes_list):
                x1, y1 = adjusted_pos[node1]
                w1, h1 = node_rects[node1]['width'], node_rects[node1]['height']
                
                for node2 in nodes_list[i+1:]:
                    x2, y2 = adjusted_pos[node2]
                    w2, h2 = node_rects[node2]['width'], node_rects[node2]['height']
                    
                    # Check if rectangles overlap
                    # Overlap if: |x1-x2| < (w1+w2)/2 AND |y1-y2| < (h1+h2)/2
                    x_overlap = abs(x1 - x2) < (w1 + w2) / 2
                    y_overlap = abs(y1 - y2) < (h1 + h2) / 2
                    
                    if x_overlap and y_overlap:
                        overlaps_found = True
                        # Separate nodes: move them apart
                        sep_x = (w1 + w2) / 2 + 20  # Minimum 20 units separation
                        sep_y = (h1 + h2) / 2 + 20
                        
                        if x1 < x2:
                            adjusted_pos[node1] = (x1 - sep_x/4, y1)
                            adjusted_pos[node2] = (x2 + sep_x/4, y2)
                        else:
                            adjusted_pos[node1] = (x1 + sep_x/4, y1)
                            adjusted_pos[node2] = (x2 - sep_x/4, y2)
                        
                        if y1 < y2:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 - sep_y/4)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 + sep_y/4)
                        else:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 + sep_y/4)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 - sep_y/4)
            
            if not overlaps_found:
                break
        
        # Third pass: Draw rectangles and texts with adjusted positions
        for node in subgraph.nodes():
            x, y = adjusted_pos[node]
            rect_info = node_rects[node]
            node_color = rect_info['color']
            rect_width = rect_info['width']
            rect_height = rect_info['height']
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Use adjusted positions for calculating limits
        x_values = [adjusted_pos[node][0] for node in subgraph.nodes()]
        y_values = [adjusted_pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes using new formula
            max_rect_width = 0
            node_font_size = font_size
            for node in subgraph.nodes():
                char_width_factor = 0.7
                base_width = len(node) * node_font_size * char_width_factor
                
                # Use same padding logic as in rectangle creation
                if len(node) > 40:
                    padding_factor = 0.8
                elif len(node) > 30:
                    padding_factor = 0.7
                else:
                    padding_factor = 0.6
                
                padding = base_width * padding_factor
                rect_width = base_width + padding
                min_width = node_font_size * 10
                rect_width = max(rect_width, min_width)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add very generous padding based on maximum rectangle width
            # Use at least 60% of max width as padding on each side
            x_padding = max(300, max_rect_width * 0.6)  # Very generous horizontal padding
            y_padding = 120  # Increased vertical padding for taller rectangles
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with MORE spacing to prevent overlap
        try:
            # Increase nodesep and ranksep significantly to prevent node overlap
            # nodesep: minimum space between nodes in the same rank
            # ranksep: minimum space between ranks
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', 
                                              args='-Grankdir=TB -Gnodesep=2.0 -Granksep=1.5 -Gmargin=0.5')
        except (ImportError, Exception) as e:
            # Fallback if graphviz is not available or fails
            # Use spring layout with increased iterations and k parameter for better spacing
            print(f"Warning: Graphviz not available or failed ({e}). Using spring layout with increased spacing.")
            # Increase k (optimal distance between nodes) based on number of nodes and their width
            # Estimate average node width
            avg_node_width = sum(len(node) * font_size * 0.7 for node in subgraph.nodes()) / max(len(subgraph.nodes()), 1)
            k_value = max(avg_node_width * 1.5, 5.0)  # At least 5.0
            pos = nx.spring_layout(subgraph, k=k_value, iterations=200, seed=42)
    
        # Draw rectangle nodes with idea IDs - with different colors per level
        # (Edges will be drawn after position adjustment to prevent misalignment)
        node_font_size = font_size
        
        # First pass: Calculate all rectangle dimensions and store node info
        node_rects = {}
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Calculate rectangle dimensions
            char_width_factor = 0.7
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding
            if len(node) > 40:
                padding_factor = 0.8
            elif len(node) > 30:
                padding_factor = 0.7
            else:
                padding_factor = 0.6
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            min_width = node_font_size * 10
            rect_width = max(rect_width, min_width)
            rect_height = 50
            
            node_rects[node] = {
                'x': x, 'y': y,
                'width': rect_width, 'height': rect_height,
                'color': node_color_map[node]
            }
        
        # Second pass: Adjust positions to prevent overlap
        # Check for overlaps and adjust positions
        nodes_list = list(subgraph.nodes())
        adjusted_pos = {node: (node_rects[node]['x'], node_rects[node]['y']) for node in nodes_list}
        
        # Simple overlap resolution: if rectangles overlap, increase separation
        max_iterations = 10
        for iteration in range(max_iterations):
            overlaps_found = False
            for i, node1 in enumerate(nodes_list):
                x1, y1 = adjusted_pos[node1]
                w1, h1 = node_rects[node1]['width'], node_rects[node1]['height']
                
                for node2 in nodes_list[i+1:]:
                    x2, y2 = adjusted_pos[node2]
                    w2, h2 = node_rects[node2]['width'], node_rects[node2]['height']
                    
                    # Check if rectangles overlap
                    # Overlap if: |x1-x2| < (w1+w2)/2 AND |y1-y2| < (h1+h2)/2
                    x_overlap = abs(x1 - x2) < (w1 + w2) / 2
                    y_overlap = abs(y1 - y2) < (h1 + h2) / 2
                    
                    if x_overlap and y_overlap:
                        overlaps_found = True
                        # Separate nodes: move them apart
                        sep_x = (w1 + w2) / 2 + 20  # Minimum 20 units separation
                        sep_y = (h1 + h2) / 2 + 20
                        
                        if x1 < x2:
                            adjusted_pos[node1] = (x1 - sep_x/4, y1)
                            adjusted_pos[node2] = (x2 + sep_x/4, y2)
                        else:
                            adjusted_pos[node1] = (x1 + sep_x/4, y1)
                            adjusted_pos[node2] = (x2 - sep_x/4, y2)
                        
                        if y1 < y2:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 - sep_y/4)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 + sep_y/4)
                        else:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 + sep_y/4)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 - sep_y/4)
            
            if not overlaps_found:
                break
        
        # Third pass: Draw rectangles and texts with adjusted positions
        for node in subgraph.nodes():
            x, y = adjusted_pos[node]
            rect_info = node_rects[node]
            node_color = rect_info['color']
            rect_width = rect_info['width']
            rect_height = rect_info['height']
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
        
        # Draw edges AFTER position adjustment to ensure they align with nodes
        nx.draw_networkx_edges(subgraph, adjusted_pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Use adjusted positions for calculating limits
        x_values = [adjusted_pos[node][0] for node in subgraph.nodes()]
        y_values = [adjusted_pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes using new formula
            max_rect_width = 0
            node_font_size = font_size
            for node in subgraph.nodes():
                char_width_factor = 0.7
                base_width = len(node) * node_font_size * char_width_factor
                
                # Use same padding logic as in rectangle creation
                if len(node) > 40:
                    padding_factor = 0.8
                elif len(node) > 30:
                    padding_factor = 0.7
                else:
                    padding_factor = 0.6
                
                padding = base_width * padding_factor
                rect_width = base_width + padding
                min_width = node_font_size * 10
                rect_width = max(rect_width, min_width)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add very generous padding based on maximum rectangle width
            # Use at least 60% of max width as padding on each side
            x_padding = max(300, max_rect_width * 0.6)  # Very generous horizontal padding
            y_padding = 120  # Increased vertical padding for taller rectangles
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查代碼是否有遺漏或錯誤：


調整繪製順序，先繪邊再繪節點：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with MORE spacing to prevent overlap
        try:
            # Increase nodesep and ranksep significantly to prevent node overlap
            # nodesep: minimum space between nodes in the same rank
            # ranksep: minimum space between ranks
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', 
                                              args='-Grankdir=TB -Gnodesep=2.0 -Granksep=1.5 -Gmargin=0.5')
        except (ImportError, Exception) as e:
            # Fallback if graphviz is not available or fails
            # Use spring layout with increased iterations and k parameter for better spacing
            print(f"Warning: Graphviz not available or failed ({e}). Using spring layout with increased spacing.")
            # Increase k (optimal distance between nodes) based on number of nodes and their width
            # Estimate average node width
            avg_node_width = sum(len(node) * font_size * 0.7 for node in subgraph.nodes()) / max(len(subgraph.nodes()), 1)
            k_value = max(avg_node_width * 1.5, 5.0)  # At least 5.0
            pos = nx.spring_layout(subgraph, k=k_value, iterations=200, seed=42)
    
        # Calculate all rectangle dimensions and adjust positions to prevent overlap
        node_font_size = font_size
        
        # First pass: Calculate all rectangle dimensions and store node info
        node_rects = {}
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Calculate rectangle dimensions
            char_width_factor = 0.7
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding
            if len(node) > 40:
                padding_factor = 0.8
            elif len(node) > 30:
                padding_factor = 0.7
            else:
                padding_factor = 0.6
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            min_width = node_font_size * 10
            rect_width = max(rect_width, min_width)
            rect_height = 50
            
            node_rects[node] = {
                'x': x, 'y': y,
                'width': rect_width, 'height': rect_height,
                'color': node_color_map[node]
            }
        
        # Second pass: Adjust positions to prevent overlap
        # Check for overlaps and adjust positions iteratively
        nodes_list = list(subgraph.nodes())
        adjusted_pos = {node: (node_rects[node]['x'], node_rects[node]['y']) for node in nodes_list}
        
        # Improved overlap resolution with better separation
        max_iterations = 15
        for iteration in range(max_iterations):
            overlaps_found = False
            for i, node1 in enumerate(nodes_list):
                x1, y1 = adjusted_pos[node1]
                w1, h1 = node_rects[node1]['width'], node_rects[node1]['height']
                
                for node2 in nodes_list[i+1:]:
                    x2, y2 = adjusted_pos[node2]
                    w2, h2 = node_rects[node2]['width'], node_rects[node2]['height']
                    
                    # Check if rectangles overlap
                    # Overlap if: |x1-x2| < (w1+w2)/2 AND |y1-y2| < (h1+h2)/2
                    min_sep_x = (w1 + w2) / 2 + 30  # Minimum 30 units horizontal separation
                    min_sep_y = (h1 + h2) / 2 + 30  # Minimum 30 units vertical separation
                    
                    x_overlap = abs(x1 - x2) < min_sep_x
                    y_overlap = abs(y1 - y2) < min_sep_y
                    
                    if x_overlap and y_overlap:
                        overlaps_found = True
                        # Calculate how much to move each node
                        move_x = (min_sep_x - abs(x1 - x2)) / 2 + 10  # Add 10 units extra
                        move_y = (min_sep_y - abs(y1 - y2)) / 2 + 10
                        
                        # Move nodes apart
                        if x1 < x2:
                            adjusted_pos[node1] = (x1 - move_x, adjusted_pos[node1][1])
                            adjusted_pos[node2] = (x2 + move_x, adjusted_pos[node2][1])
                        else:
                            adjusted_pos[node1] = (x1 + move_x, adjusted_pos[node1][1])
                            adjusted_pos[node2] = (x2 - move_x, adjusted_pos[node2][1])
                        
                        if y1 < y2:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 - move_y)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 + move_y)
                        else:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 + move_y)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 - move_y)
            
            if not overlaps_found:
                break
        
        # Draw edges FIRST (so they appear behind nodes)
        nx.draw_networkx_edges(subgraph, adjusted_pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
        
        # Third pass: Draw rectangles and texts with adjusted positions
        for node in subgraph.nodes():
            x, y = adjusted_pos[node]
            rect_info = node_rects[node]
            node_color = rect_info['color']
            rect_width = rect_info['width']
            rect_height = rect_info['height']
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Use adjusted positions for calculating limits
        x_values = [adjusted_pos[node][0] for node in subgraph.nodes()]
        y_values = [adjusted_pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes using new formula
            max_rect_width = 0
            node_font_size = font_size
            for node in subgraph.nodes():
                char_width_factor = 0.7
                base_width = len(node) * node_font_size * char_width_factor
                
                # Use same padding logic as in rectangle creation
                if len(node) > 40:
                    padding_factor = 0.8
                elif len(node) > 30:
                    padding_factor = 0.7
                else:
                    padding_factor = 0.6
                
                padding = base_width * padding_factor
                rect_width = base_width + padding
                min_width = node_font_size * 10
                rect_width = max(rect_width, min_width)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add very generous padding based on maximum rectangle width
            # Use at least 60% of max width as padding on each side
            x_padding = max(300, max_rect_width * 0.6)  # Very generous horizontal padding
            y_padding = 120  # Increased vertical padding for taller rectangles
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=45, y=1.0)  # Maximum pad and position at top
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

檢查表格部分，確保標題與表格的間距足夠：


```python
import json
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import textwrap
from matplotlib.patches import Rectangle, FancyBboxPatch
from collections import defaultdict
import matplotlib.colors as mcolors
import os

def visualize_hypotheses(json_file_path, output_pdf_path=None, font_size=11, max_evidence_items=20):
    """
    Visualize hypotheses and their relationships from a JSON file.
    
    Parameters:
    -----------
    json_file_path : str
        Path to the JSON file containing idea data
    output_pdf_path : str, optional
        Path for the output PDF file. If None, will use the input filename with '_visualization.pdf'
    font_size : int, optional
        Font size for idea content (default: 11)
    max_evidence_items : int, optional
        Maximum number of evidence items to display (default: 20)
        
    Returns:
    --------
    str
        Path to the generated PDF file
    """
    
    # Set default output path if not provided
    if output_pdf_path is None:
        base_name = os.path.splitext(os.path.basename(json_file_path))[0]
        output_pdf_path = f"{base_name}_visualization.pdf"
    
    # Load the JSON data
    with open(json_file_path, 'r') as file:
        data = json.load(file)
    
    # Create a PDF file to save all visualizations
    pdf = PdfPages(output_pdf_path)
    
    # Function to get idea details
    def get_idea_details(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea
        return None

    # Function to get parent idea
    def get_parent(idea_id):
        for idea in data['ideas']:
            if idea['id'] == idea_id:
                return idea.get('parent_id')
        return None
    
    # Function to get all ancestors of an idea
    def get_ancestors(idea_id):
        ancestors = []
        parent_id = get_parent(idea_id)
        while parent_id:
            ancestors.append(parent_id)
            parent_id = get_parent(parent_id)
        return ancestors
    
    # Function to wrap text
    def wrap_text(text, width=40):
        return '\n'.join(textwrap.wrap(text, width=width))
    
    # Improved color palette for different idea levels (colorblind-friendly)
    level_colors = [
        '#E69F00',  # Orange - Current idea
        '#56B4E9',  # Blue - Level 1 parent
        '#009E73',  # Green - Level 2 parent
        '#F0E442',  # Yellow - Level 3 parent
        '#0072B2',  # Dark blue - Level 4 parent
        '#D55E00',  # Red-brown - Level 5 parent
        '#CC79A7',  # Pink - Level 6 parent
        '#999999',  # Grey - Level 7+ parent
    ]
    
    # Extract top ideas
    top_ideas = data.get('top_ideas', [])
    if not top_ideas:
        # If top_ideas not explicitly defined, find ideas with iteration > 0
        for idea in data['ideas']:
            if idea.get('iteration', 0) > 0:
                top_ideas.append(idea['id'])

    print(f"Top Ideas: {top_ideas}")
    
    # Create a graph to represent idea inheritance
    G = nx.DiGraph()

    # Add all ideas to the graph
    for idea in data['ideas']:
        idea_id = idea['id']
        parent_id = idea.get('parent_id')

        # Add node with attributes
        scores = idea.get('scores', {})
        avg_score = sum(scores.values()) / len(scores) if scores else 0

        # Check if this is a top idea
        is_top = idea_id in top_ideas

        # Get evidence titles
        evidence_titles = [e['title'] for e in idea.get('evidence', [])]

        G.add_node(idea_id,
                   text=idea['text'],
                   scores=scores,
                   avg_score=avg_score,
                   is_top=is_top,
                   evidence=evidence_titles)

        # Add edge from parent to child
        if parent_id:
            G.add_edge(parent_id, idea_id)
    
    # Calculate text height based on content
    def calculate_text_height(text, width=60):  # Further reduced width for better estimation
        wrapped = wrap_text(text, width)
        return len(wrapped.split('\n'))
    
    # For each top idea, create a comprehensive visualization
    for idea_id in top_ideas:
        # Estimate number of ancestors to determine figure size
        ancestors = get_ancestors(idea_id)
        num_ideas = len(ancestors) + 1

        # Dynamically adjust figure size based on number of ideas
        # More ideas need taller figure
        base_height = 20
        height_per_idea = 2.5
        fig_height = max(base_height, 15 + (num_ideas * height_per_idea))
        
        # Create a figure with increased height
        fig = plt.figure(figsize=(20, fig_height))
        
        # Create GridSpec with more separation between sections
        # Increase middle section height to accommodate method details
        # Increase bottom section for table with more space and prevent overlap
        gs = fig.add_gridspec(3, 2, width_ratios=[1, 2], 
                             height_ratios=[1, 3.5, 2.5],  # Further increased bottom section for table
                             left=0.05, right=0.95, 
                             bottom=0.05, top=0.92, 
                             wspace=0.1, hspace=0.3)  # Increased vertical space between sections
    
        # Get all ancestors of this idea
        relevant_nodes = [idea_id] + ancestors
    
        # Reverse the list to have the oldest ancestor first
        relevant_nodes_ordered = list(reversed(relevant_nodes))
    
        # Create a mapping of node to level (for coloring)
        node_level_map = {node: idx for idx, node in enumerate(relevant_nodes_ordered)}
    
        # Create a mapping of node to color
        node_color_map = {node: level_colors[min(idx, len(level_colors)-1)] 
                          for node, idx in node_level_map.items()}
    
        # Create subgraph
        subgraph = G.subgraph(relevant_nodes)
    
        # 1. Inheritance relationship (top section) - now in its own row
        ax1 = fig.add_subplot(gs[0, :])  # Span both columns in the top row
    
        # Layout for the subgraph - use a hierarchical layout with MORE spacing to prevent overlap
        try:
            # Increase nodesep and ranksep significantly to prevent node overlap
            # nodesep: minimum space between nodes in the same rank
            # ranksep: minimum space between ranks
            pos = nx.nx_agraph.graphviz_layout(subgraph, prog='dot', 
                                              args='-Grankdir=TB -Gnodesep=2.0 -Granksep=1.5 -Gmargin=0.5')
        except (ImportError, Exception) as e:
            # Fallback if graphviz is not available or fails
            # Use spring layout with increased iterations and k parameter for better spacing
            print(f"Warning: Graphviz not available or failed ({e}). Using spring layout with increased spacing.")
            # Increase k (optimal distance between nodes) based on number of nodes and their width
            # Estimate average node width
            avg_node_width = sum(len(node) * font_size * 0.7 for node in subgraph.nodes()) / max(len(subgraph.nodes()), 1)
            k_value = max(avg_node_width * 1.5, 5.0)  # At least 5.0
            pos = nx.spring_layout(subgraph, k=k_value, iterations=200, seed=42)
    
        # Calculate all rectangle dimensions and adjust positions to prevent overlap
        node_font_size = font_size
        
        # First pass: Calculate all rectangle dimensions and store node info
        node_rects = {}
        for node in subgraph.nodes():
            x, y = pos[node]
            
            # Calculate rectangle dimensions
            char_width_factor = 0.7
            base_width = len(node) * node_font_size * char_width_factor
            
            # Add VERY generous padding
            if len(node) > 40:
                padding_factor = 0.8
            elif len(node) > 30:
                padding_factor = 0.7
            else:
                padding_factor = 0.6
            
            padding = base_width * padding_factor
            rect_width = base_width + padding
            min_width = node_font_size * 10
            rect_width = max(rect_width, min_width)
            rect_height = 50
            
            node_rects[node] = {
                'x': x, 'y': y,
                'width': rect_width, 'height': rect_height,
                'color': node_color_map[node]
            }
        
        # Second pass: Adjust positions to prevent overlap
        # Check for overlaps and adjust positions iteratively
        nodes_list = list(subgraph.nodes())
        adjusted_pos = {node: (node_rects[node]['x'], node_rects[node]['y']) for node in nodes_list}
        
        # Improved overlap resolution with better separation
        max_iterations = 15
        for iteration in range(max_iterations):
            overlaps_found = False
            for i, node1 in enumerate(nodes_list):
                x1, y1 = adjusted_pos[node1]
                w1, h1 = node_rects[node1]['width'], node_rects[node1]['height']
                
                for node2 in nodes_list[i+1:]:
                    x2, y2 = adjusted_pos[node2]
                    w2, h2 = node_rects[node2]['width'], node_rects[node2]['height']
                    
                    # Check if rectangles overlap
                    # Overlap if: |x1-x2| < (w1+w2)/2 AND |y1-y2| < (h1+h2)/2
                    min_sep_x = (w1 + w2) / 2 + 30  # Minimum 30 units horizontal separation
                    min_sep_y = (h1 + h2) / 2 + 30  # Minimum 30 units vertical separation
                    
                    x_overlap = abs(x1 - x2) < min_sep_x
                    y_overlap = abs(y1 - y2) < min_sep_y
                    
                    if x_overlap and y_overlap:
                        overlaps_found = True
                        # Calculate how much to move each node
                        move_x = (min_sep_x - abs(x1 - x2)) / 2 + 10  # Add 10 units extra
                        move_y = (min_sep_y - abs(y1 - y2)) / 2 + 10
                        
                        # Move nodes apart
                        if x1 < x2:
                            adjusted_pos[node1] = (x1 - move_x, adjusted_pos[node1][1])
                            adjusted_pos[node2] = (x2 + move_x, adjusted_pos[node2][1])
                        else:
                            adjusted_pos[node1] = (x1 + move_x, adjusted_pos[node1][1])
                            adjusted_pos[node2] = (x2 - move_x, adjusted_pos[node2][1])
                        
                        if y1 < y2:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 - move_y)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 + move_y)
                        else:
                            adjusted_pos[node1] = (adjusted_pos[node1][0], y1 + move_y)
                            adjusted_pos[node2] = (adjusted_pos[node2][0], y2 - move_y)
            
            if not overlaps_found:
                break
        
        # Draw edges FIRST (so they appear behind nodes)
        nx.draw_networkx_edges(subgraph, adjusted_pos, edge_color='gray', arrows=True, 
                              arrowstyle='-|>', arrowsize=15, width=1.5, ax=ax1)
        
        # Third pass: Draw rectangles and texts with adjusted positions
        for node in subgraph.nodes():
            x, y = adjusted_pos[node]
            rect_info = node_rects[node]
            node_color = rect_info['color']
            rect_width = rect_info['width']
            rect_height = rect_info['height']
            
            # Create rectangle with rounded corners and generous padding
            rect = FancyBboxPatch((x - rect_width/2, y - rect_height/2), 
                                 rect_width, rect_height, 
                                 boxstyle="round,pad=1.5",  # Very generous padding (1.5 units)
                                 facecolor=node_color,
                                 edgecolor='black',
                                 alpha=0.8,
                                 linewidth=1.5)  # Thicker border for better visibility
            ax1.add_patch(rect)
            
            # Add node ID text
            # Use wrap text for very long IDs to prevent overflow
            display_text = node
            if len(node) > 45:  # For extremely long IDs
                # Split into two lines if possible
                mid_point = len(node) // 2
                # Try to split at underscore for better readability
                split_pos = node[:mid_point].rfind('_')
                if split_pos > 0:
                    display_text = node[:split_pos] + '\n' + node[split_pos+1:]
                else:
                    display_text = node[:mid_point] + '\n' + node[mid_point:]
            
            text_obj = ax1.text(x, y, display_text, ha='center', va='center', 
                               fontsize=node_font_size, 
                               fontweight='bold', color='black',
                               clip_on=True)  # Enable clipping to prevent overflow
    
        # Adjust the axis limits to ensure all nodes are visible with padding
        # Use adjusted positions for calculating limits
        x_values = [adjusted_pos[node][0] for node in subgraph.nodes()]
        y_values = [adjusted_pos[node][1] for node in subgraph.nodes()]
        
        if x_values and y_values:  # Check if lists are not empty
            # Calculate maximum rectangle width needed for all nodes using new formula
            max_rect_width = 0
            node_font_size = font_size
            for node in subgraph.nodes():
                char_width_factor = 0.7
                base_width = len(node) * node_font_size * char_width_factor
                
                # Use same padding logic as in rectangle creation
                if len(node) > 40:
                    padding_factor = 0.8
                elif len(node) > 30:
                    padding_factor = 0.7
                else:
                    padding_factor = 0.6
                
                padding = base_width * padding_factor
                rect_width = base_width + padding
                min_width = node_font_size * 10
                rect_width = max(rect_width, min_width)
                max_rect_width = max(max_rect_width, rect_width)
            
            # Add very generous padding based on maximum rectangle width
            # Use at least 60% of max width as padding on each side
            x_padding = max(300, max_rect_width * 0.6)  # Very generous horizontal padding
            y_padding = 120  # Increased vertical padding for taller rectangles
            
            x_min, x_max = min(x_values) - x_padding, max(x_values) + x_padding
            y_min, y_max = min(y_values) - y_padding, max(y_values) + y_padding
            
            ax1.set_xlim(x_min, x_max)
            ax1.set_ylim(y_min, y_max)
        
        ax1.set_title(f'Inheritance Relationship for Idea {idea_id}', fontsize=14, pad=10)
        ax1.axis('off')
    
        # 2. Idea content (middle section) - now in its own row
        ax2 = fig.add_subplot(gs[1, :])  # Span both columns in the middle row
        ax2.axis('off')
    
        # Pre-calculate text heights to better position boxes
        text_heights = {}
        total_height_needed = 0
        
        for node in relevant_nodes_ordered:
            idea = get_idea_details(node)
            if idea:
                text = idea['text']
                scores = idea.get('scores', {})
                
                # Calculate height based on content - use smaller width for wrapping
                text_height = calculate_text_height(text, width=60)
                
                # Check if this is current idea (for this page) with refined_method_details
                is_current_for_page = node == idea_id
                method_extra_height = 0
                if is_current_for_page:
                    refined_method = idea.get('refined_method_details', {})
                    if refined_method:
                        # Estimate extra height for method details
                        method_desc = refined_method.get('description', '')
                        method_data = refined_method.get('method', {})
                        if method_desc:
                            method_extra_height += len(textwrap.wrap(method_desc, width=80)) + 3
                        if isinstance(method_data, dict) and 'System Architecture' in method_data:
                            arch_overview = method_data['System Architecture'].get('Overview', '')
                            if arch_overview:
                                method_extra_height += len(textwrap.wrap(arch_overview, width=80)) + 3
                
                # Base height + title + content lines + scores + method details + padding
                total_height = 3 + text_height + (2 if scores else 1) + method_extra_height
                text_heights[node] = total_height
                total_height_needed += total_height
        
        # Calculate scaling factor based on total content and available space
        # Adjust based on number of ideas
        max_total_height = 40 * (1 + (num_ideas / 10))  # Scale with number of ideas
        scale_factor = min(0.022, 0.9 / (total_height_needed / max_total_height))
        
        # Create a grid layout for idea content boxes
        num_cols = min(2, num_ideas)  # Use 2 columns if we have enough ideas
        num_rows = (num_ideas + num_cols - 1) // num_cols  # Ceiling division
        
        # Calculate grid positions
        grid_positions = []
        for i, node in enumerate(relevant_nodes_ordered):
            row = i // num_cols
            col = i % num_cols
            grid_positions.append((row, col))
        
        # Calculate grid cell size
        cell_width = 1.0 / num_cols
        cell_height = 1.0 / num_rows
        
        # Process ideas in the same order as the inheritance graph
        for i, node in enumerate(relevant_nodes_ordered):
            idea = get_idea_details(node)
            if idea:
                # Use smaller width for wrapping to prevent text overflow
                idea_text = wrap_text(idea['text'], width=60)
                scores = idea.get('scores', {})
                score_text = ', '.join([f"{k}: {v:.1f}" for k, v in scores.items()]) if scores else "No scores"
                
                # Determine if this is the current idea
                is_current = node == idea_id
                
                # Get the appropriate color from the map
                box_color = node_color_map[node]
                
                # Create content - include refined_method_details if available
                title = "CURRENT HYPOTHESIS: " if is_current else "PARENT HYPOTHESIS: "
                content = f"{title}{node}\n\nCONTENT: {idea_text}\n\nSCORES: {score_text}"
                
                # Add refined method details if available (for current idea)
                refined_method = idea.get('refined_method_details', {})
                if refined_method and is_current:
                    method_title = refined_method.get('title', '')
                    method_desc = refined_method.get('description', '')
                    method_name = refined_method.get('name', '')
                    
                    if method_name or method_title:
                        method_header = f"\n\n=== METHOD DETAILS ===\n"
                        if method_name:
                            method_header += f"Name: {method_name}\n"
                        if method_title:
                            method_header += f"Title: {method_title}\n"
                        if method_desc:
                            # Truncate description if too long, but allow more space
                            desc_lines = textwrap.wrap(method_desc, width=80)
                            method_desc_short = '\n'.join(desc_lines[:5])  # Show first 5 lines
                            if len(desc_lines) > 5:
                                method_desc_short += "\n..."
                            method_header += f"Description: {method_desc_short}\n"
                        
                        # Try to extract key method info
                        method_data = refined_method.get('method', {})
                        if method_data and isinstance(method_data, dict):
                            if 'System Architecture' in method_data:
                                arch_overview = method_data['System Architecture'].get('Overview', '')
                                if arch_overview:
                                    arch_lines = textwrap.wrap(arch_overview, width=80)
                                    arch_short = '\n'.join(arch_lines[:3])  # Show first 3 lines
                                    if len(arch_lines) > 3:
                                        arch_short += "\n..."
                                    method_header += f"\nArchitecture Overview:\n{arch_short}\n"
                        
                        content += method_header
                
                # Create a text box with matching color and rounded corners
                props = dict(boxstyle='round,pad=0.8', facecolor=box_color, alpha=0.3)
                
                # Get grid position
                row, col = grid_positions[i]
                
                # Calculate position in the subplot
                x_pos = col * cell_width + 0.01
                y_pos = 1.0 - (row * cell_height) - 0.05
                
                # Calculate box width and height
                box_width = cell_width * 0.98
                box_height = cell_height * 0.9
                
                # Add text box with appropriate font size
                # Adjust font size based on content length and available space
                content_length = len(content)
                adjusted_font_size = max(7, min(font_size, 11 - (content_length // 800)))  # Adjusted for longer content
                
                ax2.text(x_pos, y_pos, content, transform=ax2.transAxes,
                        fontsize=adjusted_font_size,
                        verticalalignment='top', horizontalalignment='left',
                        bbox=props, wrap=True)
    
        ax2.set_title('Idea Content and Scores (Current and Parents)', fontsize=14, pad=10)
    
        # 3. Evidence used (bottom section) - now in its own row
        ax3 = fig.add_subplot(gs[2, :])  # Span both columns in the bottom row
        ax3.axis('off')
    
        # Collect evidence from this idea and all its ancestors
        evidence_by_idea = defaultdict(list)
        all_evidence = []
    
        for node_id in relevant_nodes:
            idea = get_idea_details(node_id)
            if idea and 'evidence' in idea:
                for evidence in idea['evidence']:
                    # Get the idea color for this evidence
                    evidence_color = node_color_map[node_id]

                    evidence_item = {
                        'idea_id': node_id,
                        'title': evidence['title'],
                        'authors': evidence.get('authors', ''),
                        'year': evidence.get('year', ''),
                        'relevance_score': evidence.get('relevance_score', 0),
                        'color': evidence_color
                    }
                    all_evidence.append(evidence_item)
                    evidence_by_idea[node_id].append(evidence_item)

        # Sort all evidence by relevance score
        all_evidence.sort(key=lambda x: x['relevance_score'], reverse=True)
    
        # Create table data with reference numbers and idea IDs
        table_data = []
        cell_colors = []
        
        for i, evidence in enumerate(all_evidence):
            if i >= max_evidence_items:  # Use the parameter to limit items
                break
            
            # Keep full title, but wrap it for display in table cells
            full_title = evidence['title']
            
            # Create row data - use full title, matplotlib table will handle wrapping
            row = [
                str(i+1),  # Reference number
                full_title,  # Full title - no truncation
                evidence['idea_id'],  # Add idea ID
                str(evidence['year']),
                f"{evidence['relevance_score']:.2f}"
            ]
            table_data.append(row)
            
            # Create row colors (use light version of the idea color)
            row_color = [evidence['color']] * 5
            cell_colors.append(row_color)
    
        # Create table with optimized column widths
        if table_data:
            # Pre-process titles: wrap them and find maximum number of lines
            # CRITICAL: Count lines correctly, including already multi-line titles
            max_lines_per_title = 1
            wrapped_titles = []
            for row in table_data:
                title_text = row[1]  # Title is in column 1
                # Count existing newlines first
                existing_lines = title_text.count('\n') + 1
                
                # If text is too long, wrap it
                if len(title_text) > 60:
                    # Split by newlines first, then wrap each line if needed
                    parts = title_text.split('\n')
                    all_wrapped = []
                    for part in parts:
                        if len(part) > 60:
                            wrapped_lines = textwrap.wrap(part, width=60)
                            all_wrapped.extend(wrapped_lines)
                        else:
                            all_wrapped.append(part)
                    wrapped_title = '\n'.join(all_wrapped)
                    wrapped_titles.append(wrapped_title)
                    max_lines_per_title = max(max_lines_per_title, len(all_wrapped))
                else:
                    wrapped_titles.append(title_text)
                    max_lines_per_title = max(max_lines_per_title, existing_lines)
            
            # Update table_data with wrapped titles
            for i, wrapped_title in enumerate(wrapped_titles):
                table_data[i][1] = wrapped_title
            
            # Calculate uniform row height based on maximum lines
            # Add extra space at bottom to prevent text from crossing grid lines
            # Use slightly larger height per line to ensure text doesn't touch bottom grid line
            uniform_row_height = 0.028 * max_lines_per_title + 0.012  # Extra padding for bottom margin
            uniform_row_height = max(uniform_row_height, 0.048)  # Minimum height with padding
            
            # Create the table with custom column widths - increased title width
            table = plt.table(
                cellText=table_data,
                colLabels=['#', 'Title', 'Idea', 'Year', 'Relevance'],
                cellLoc='left',
                loc='center',
                colWidths=[0.02, 0.70, 0.15, 0.04, 0.09]  # Increased title width from 0.65 to 0.70
            )
            
            # Apply cell colors with reduced alpha for better readability
            for (i, j), cell in table.get_celld().items():
                if i > 0:  # Skip header row
                    cell.set_facecolor(mcolors.to_rgba(cell_colors[i-1][j], alpha=0.2))
            
            # Format the table for better readability
            table.auto_set_font_size(False)
            table.set_fontsize(7)  # Base font size
            # DO NOT use table.scale() as it can override our height settings
            
            # First pass: Set uniform cell heights for all cells in each row
            # This ensures all rows have the same height
            # IMPORTANT: Process ALL cells in a row to force uniform height
            for i in range(len(table_data) + 1):  # +1 for header
                if i == 0:  # Header row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        cell.set_height(0.045)  # Reduced header height
                        cell.get_text().set_fontsize(7)  # Slightly smaller font
                        cell.get_text().set_weight('bold')
                        cell.get_text().set_va('center')  # Center align header text
                else:  # Data rows - CRITICAL: use uniform height for ALL cells in the row
                    for j in range(5):  # 5 columns
                        cell = table[(i, j)]
                        # Force same height for all columns in the same row
                        cell.set_height(uniform_row_height)
            
            # Second pass: Set text properties (height is already set uniformly)
            for i in range(1, len(table_data) + 1):  # Data rows only (skip header)
                for j in range(5):  # All columns
                    cell = table[(i, j)]
                    # Configure text alignment - top align to prevent crossing grid lines
                    if j == 1:  # Title column
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top for multi-line text
                        cell.get_text().set_ha('left')
                    elif j == 2:  # Idea column
                        cell.get_text().set_fontsize(6)
                        cell.get_text().set_wrap(True)
                        cell.get_text().set_va('top')  # Align to top to match title column
                        cell.get_text().set_ha('left')
                    else:  # Other columns (#, Year, Relevance)
                        cell.get_text().set_fontsize(7)
                        cell.get_text().set_va('top')  # Align to top - will show near top with bottom space
                        cell.get_text().set_ha('left')
    
        # Position title higher with more padding to ensure no overlap with table
        ax3.set_title('Evidence Used by This Idea and Its Ancestors', fontsize=14, pad=60, y=1.05)  # Increased pad and higher position
    
        # Set the main title for the entire figure - positioned lower to avoid overlap
        plt.suptitle(f'Comprehensive View of Top Idea: {idea_id}', fontsize=16, y=0.98)
    
        # Save the figure with tight layout
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)
    
    # Save and close the PDF file
    pdf.close()
    print(f"Visualization saved to {output_pdf_path}")
    
    return output_pdf_path

```

已修正文字與表格重疊問題。主要改進如下：

## 修正內容

### 1. **增加布局節點間距**

**Graphviz 布局**：
- `nodesep`: 從 `0.3` 增加到 `2.0`
- `ranksep`: 從 `0.4` 增加到 `1.5`
- 添加 `margin=0.5` 確保邊界空間

**Spring Layout（fallback）**：
- 動態計算 `k` 值（節點間距）
- 迭代次數增加到 `200`
- 根據平均節點寬度設置 `k` 值

### 2. **自動重疊檢測與調整機制**

**三步驟處理**：
1. 計算所有節點的矩形尺寸
2. 檢測重疊並調整位置（最多 15 次迭代）
3. 使用調整後的位置繪製節點和邊

**重疊檢測邏輯**：
- 檢查矩形是否在 X 和 Y 方向都重疊
- 最小間距：水平 30 單位 + 矩形寬度，垂直 30 單位 + 矩形高度
- 自動將重疊節點分離

### 3. **繪製順序修正**

- 先繪製邊（在背景）
- 再繪製節點矩形（在中間）
- 最後繪製文字（在前景）

### 4. **表格標題間距**

- `pad` 從 `45` 增加到 `60`
- `y` 從 `1.0` 增加到 `1.05`（更高位置）

## 改進重點

**重疊解決算法**：
- 迭代檢測所有節點對的重疊
- 動態計算分離距離
- 同時調整 X 和 Y 方向的位置
- 最多 15 次迭代確保完全分離

**布局參數優化**：
- 大幅增加節點間距參數
- 根據節點大小動態調整布局參數

請重新生成 PDF 測試，應該會看到：
- ✅ 所有節點之間有足夠間距，不會重疊
- ✅ 邊正確連接到調整後的節點位置
- ✅ 表格與標題之間有充足的間距
- ✅ 所有文字清晰可見，無重疊

如果還有問題，請告訴我具體情況，我會繼續調整。

